<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
  	<!-- 支持注解   <context:annotation-config/>   -->
	  <context:annotation-config/>
      	  
	   <!-- spring  本身扫描注解类型 -->
	 <context:component-scan base-package="com.old">
	 	<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	     
	 <!-- 自动读取property -->
	<context:property-placeholder location="classpath:config/config.properties" />

    <bean id = "dataSource" class = "com.alibaba.druid.pool.DruidDataSource" destroy-method="close" >  
         <!-- 数据库基本信息配置 -->
         <property name = "url"  value ="${hikaricp.url}" />  
         <property name ="username"  value ="${hikaricp.username}" />  
         <property name = "password"  value = "${hikaricp.password}" />  
         <property name = "driverClassName"  value ="com.mysql.jdbc.Driver" />  
         <property name = "filters"  value = "stat" />  
          <!-- 最大并发连接数 -->
         <property name = "maxActive"  value = "10" />
         <!-- 初始化连接数量 -->
         <property name = "initialSize"  value = "1" />
         <!-- 配置获取连接等待超时的时间 -->
         <property name = "maxWait"  value = "60000" />
         <!-- 最小空闲连接数 -->
         <property name = "minIdle"  value = "10" />  
          <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
         <property name = "timeBetweenEvictionRunsMillis"  value ="60000" />
         <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
         <property name = "minEvictableIdleTimeMillis"  value ="300000" />  
         <property name = "validationQuery"  value = "SELECT 'x'" />  
         <property name = "testWhileIdle"  value = "true" />  
         <property name = "testOnBorrow"  value = "false" />  
         <property name = "testOnReturn"  value = "false" />  
         <property name = "maxOpenPreparedStatements"  value ="20" />
         <!-- 打开 removeAbandoned 功能 -->
         <property name = "removeAbandoned"  value = "true" />
         <!-- 1800 秒，也就是 30 分钟 -->
         <property name = "removeAbandonedTimeout"  value ="1800" />
         <!-- 关闭 abanded 连接时输出错误日志 -->   
         <property name = "logAbandoned"  value = "true" />
    </bean>
 
	<!--采用spring管理sessionFactor -->
	<bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 引用数据源 关联-->
		<property name="dataSource" ref="dataSource" />  

			<property name="mapperLocations" value="classpath:com/old/dao/*.xml"></property>
	</bean>
	<!-- 采用自动扫描创建mapper bean  扫描配置信息  注入到 ioc 容器中 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<!-- 省去mybatis自己管理mapper bean -->
		<property name="basePackage" value="com.old.dao" />
		<property name="sqlSessionFactoryBeanName" value="sqlSessionFactoryBean" />
	</bean>
	
	<!-- 添加事务管理  避免我们手动commit -->
	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" />
	
	</bean>
	
	<!-- 采用注解管理事务 -->
	<tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" />
   
  
   
    <!-- 使用aop切面功能 开启动态代理 -->     
   <aop:aspectj-autoproxy  proxy-target-class="true"/>
   
   	 
	 <!--  spring data -redis   -->
	 <bean id="jedisPoolConfig"  class="redis.clients.jedis.JedisPoolConfig">
	 <property name="maxIdle" value="${redis.maxIdle}" />
     <property name="maxTotal" value="${redis.maxTotal}" />
        <property name="maxWaitMillis" value="${redis.maxWaitMillis}" />
        <property name="testOnBorrow" value="${redis.testOnBorrow}" />
	 </bean>
	 <bean id="jedisConnectionFactory" 
    class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy">
    <property name="hostName" value="${redis.host}" />
    <property name="port" value="${redis.port}" />
     <property name="database" value="1" />
      <property name="password" value="" />
      <property name="usePool" value="true"/>
      <property name="poolConfig" ref="jedisPoolConfig"/>
    </bean>
<!-- redis template definition -->
<bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
		<property name="connectionFactory" ref="jedisConnectionFactory" />
		<!-- 通过序列化 可以直接存储对象    如果不配置Serializer，那么存储的时候智能使用String，如果用Bean类型存储，那么会提示错误 javaBean can't cast to String！！！ -->
		<property name="keySerializer" >
		<bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/>
		</property>
		<property name="valueSerializer">  
		 <bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" />  
		</property>
  </bean>
      <!-- 对string操作的封装 -->  
    <bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"  
        p:connection-factory-ref="jedisConnectionFactory" />  
 <!--  spring data -redis  end   -->
   
   
   
   
   
</beans>